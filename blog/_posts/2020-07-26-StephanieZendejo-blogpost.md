---
layout: post
title: "Designing A Genome Class in C++"
date: 2020-07-26
author: Stephanie Zendejo
---

# Introduction to MABE :dna:
During the Summer of 2020, I had the pleasure of participating in the WAVES workshop and making contributions to MABE (Modular Agent-Based Evolution). **MABE is a tool for evolving and analyzing digital brains.** :exploding_head:  Users create and manage populations of evolving digital organisms which are then evaluated in worlds. The results of the evaluations dictate the generations of new populations by means of natural, artificial, and/or sexual selection.  

The purpose of MABE is twofold:
1. Support academic research into topics related to evolution

2. Provide insight into evolution and evolutionary processes  



# What are Digital Organisms? We just don't know. 
![WHAT ARE BIRDS](https://i.imgur.com/LUSV3Kn.jpg)  
I realized in order to have a better understanding of the project, I needed a refresher in biology. The last time I had taken a biology course was _nine_ years ago. The only thing I distinctly remembered was that _the mitochondria was the powerhouse of the cell_. I put myself through an evolutionary biology bootcamp. Once I had a good handle on terms and definitions, I worked on understanding how MABE works. 

![MABE Overview](https://i.imgur.com/WwKJYt4.png)  
**Figure MABE Structure.** _A broad overview of how MABE is structured, synonymous with how organisms evolve in the real world_  
- **Digital organisms** contain a brain which determine how the organisms interact in their environment (or world), and a genome, which provides a blueprint for the brain. A collection of organisms make up a population.

- **Archivist** is synonymous with a person who collects all data and decides what data to be stored.

- **Optimizer** is synonmyous with a person who decides which organisms in a population will produce the next generation of organisms.

- A **Group** in MABE is made up of a population of digital organisms, an optimizer, and archivist.

### Mutations
Mutations can occur in genomes. If an organism progresses to the next generation, mutations applied to the genome introduces new genetic variation into the population. In other words, a (parent) genome generates a mutated offspring genome. There are three basic mutations that can occur:
- **Overwrite:** changes the value of a single site in the genome

- **Insert:** inserts sites to the genome, changing the genome size and causing offsets

- **Remove:** removes sites from the genome, changing the genome size, and causing offsets

### Genome Class
> Genomes are often large, and undergo _several_ mutations.  

The Genome Class in MABE sets aside a chunk of contiguous memory for every genome for the organisms that progress to the next generation. It then copies the parent genome over to the contiguous memory, applies the mutations, and voila! :tada: Offspring genomes are generated. Contiguous memory for genomes is assigned and written to at every next generation. If the frequency of generating offspring genomes was reduced, could the proposed method save **time** and **memory**?  
![Loading Cat](https://i.imgur.com/6CLU31c.gif)  



# Hello Changelog!
The idea for a changelog is to record the mutations that a genome has undergone. In this way, an offspring genome would not have to be generated at every generation. The offspring genome could be generated by applying recorded mutations in the changelog to the parent genome. I set out to answer that question with my team members.

## My Approach
We can think of the parent genome as a std::vector of sites. Each site in the parent genome contains a numeric value that is represented as a byte in memory. The position of the site in the parent genome is the index.
> Insert Parent Genome Here
<!-- [Parent Genome in all its glory](https://i.imgur.com/mekOG1s.png) --->

A changelog is represented as a std::map<size_t, Site>. Size_t is the index of the site mutated, and Site is the struct to contain the mutated site's information. The Site struct identifies what type of mutation has been applied to the site, and what the new value is (if applicable).
```c++
struct Site {
	size_t insertOffset;  	  // insert mutation at site
	size_t removeOffset;   	  // remove mutation at site
	std::byte value;       	  // mutated number value
};	
std::map<size_t, Site> changelog; // key is index of site in the parent genome
                                  // value is Site structure
std::vector<std::byte> sites;     // parent genome
```
### Mutation Signatures
Here's a basic idea of what each of the functions do. I followed the mantra of _when in doubt, shift it out_.  
**Overwrite**  
  * Loops through segment vector
  * Adds overwrite mutations to the changelog  
  
Insert Overwrite Mutation Gif here  
<!-- ![OverWrite Example](https://i.imgur.com/wu7gBxK.gif) -->

**Insert**  
  * Shift sites in the changelog to the right by size of the segment vector
  * Loops through segment vector
  * Adds insert mutations to the changelog  
  
Insert Insert Mutation Gif here  
<!-- ![Insert Example](https://i.imgur.com/0rZ4Bai.gif) -->

**Remove**  
  * Removes sites in the changelog if they exist
     * Takes into account if sites removed in the changelog had insert or remove mutations
  * Shift sites in the changelog to the left
  * Adds remove mutation to the changelog  
  
Insert Remove Mutation Gif here   
<!-- ![Remove Example](https://i.imgur.com/tus7plB.gif) -->

 
The overwrite and insert signatures contain a segment vector as an argument. The segment vector is a collection of mutations that will be added to the changelog starting at the given index. 
> _insert(6, {44, 55, 66}) is the equivalent of inserting the following mutations to the changelog:_   
> _site at index 6 with a value of 44_  
> _site at index 7 with a value of 55_  
> _site at index 8 with a value of 66_  
```c++
virtual void overwrite(size_t index, const std::vector<std::byte>& segment); 
		// Ex. Starting at index 5, overwrite 3 sites with the values 11, 22, 33

virtual void insert(size_t index, const std::vector<std::byte>& segment);    
		// Ex. Starting at index 6, insert 3 new sites with the values 44, 55, 66

virtual void remove(size_t index, size_t segmentSize) override; 	     
		// Ex. At index 7, remove 3 sites
```

### Adding Entries In The Changelog
Let's apply some basic mutations to the parent genome.  

1. Overwrite mutation to site at index 2. Site has a new value of 44.
   | Key | Site Value | Remove Offset  | Insert Offset |  
   | --- |:----------:|:--------------:| -------------:|  
   |  2  |     44     |       0        |       0       |  

   _Add entry to Changelog map at key 2. Site Value is set to 44. Since this is an overwrite mutation, the size of the parent genome is not affected. Remove Offset and Insert   offset are both set to zero._  

2. Remove mutation to site at index 4. Remove 2 sites.  
   | Key | Site Value | Remove Offset  | Insert Offset |  
   | --- |:----------:|:--------------:| -------------:|  
   |  2  |     44     |       0        |       0       |  
   |  4  |      0     |       2        |       0       |  

   _Add entry to Changelog map at key 4. Site Value remains empty, since this is a remove mutation. Remove Offset is set to 2, the number of sites removed._  

3. Insert mutation to site at index 1. The inserted site will have a value of 66  
   | Key | Site Value | Remove Offset  | Insert Offset |  
   | --- |:----------:|:--------------:| -------------:|  
   |  1  |     66     |       0        |       1       |  
   |  3  |     44     |       0        |       0       |  
   |  5  |      0     |       2        |       0       |  

   _Add entry to Changelog map at key 1. Site Value is set to 66. Insert Offset is set to 1, the number of sites inserted. Shift all remaining sites in changelog to the right by one._  
   
Great! All mutations have been recorded. Much like this rendition of Celine Dion's _My Heart Will Go On_, 
> Insert youtube video here
<!--- https://www.youtube.com/watch?v=X2WH8mHJnhM -->
this genome~~'s heart~~ will go on to the next generation. We're going to use the changelog on the parent genome to generate the offspring genome. 

### Generating The Offspring Genome  
Talk about how the generateNewGenome() function works to create a new genome.  

# Time vs. Memory  
## Benchmarking  
Talk about benchmarks  
Insert Graphs
## Optimization  
Talk about improving the code itself

## Verdict  
Talk about how the Test Genome is ultimately faster ;__;

# Lessons Learned  
Talk about lessons learned  

# Acknowledgements
**Mentors:** Clifford Bohm, Jory Schossau, Jose Hernandez  
**Team Members:** Jamell Dacon, Tetiana Dadakova, Victoria Cao, Uma Sethuraman  

This work is supported through Active LENS: Learning Evolution and the Nature of Science using Evolution in Action (NSF IUSE #1432563). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.

# Resources

